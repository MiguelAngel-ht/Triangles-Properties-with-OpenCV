# -*- coding: utf-8 -*-
"""Code.ipynb

Automatically generated by Colaboratory.

# Segmentación de Triángulos
"""

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

import plotly.express as px

img = cv.imread('Triangulos.PNG', 0)
plt.imshow(img, 'gray')
plt.show()

# Function to scale a image from min to max

def ImScale(img, minf=0, maxf=255):

    x_min = img.min()
    x_max = img.max()

    img_scale = minf + ((img - x_min) / (x_max - x_min)) * (maxf - minf)
    img_scale = img_scale.astype('uint8')

    return img_scale

# binarización inversa de la imagen
ret, img_bin = cv.threshold(img, 250, 255, cv.THRESH_BINARY_INV)

# mostrar y guardar resultado
plt.imshow(img_bin, 'gray')
cv.imwrite('imagen-binaria.png', img_bin)
plt.show()

# obtener, número de objetos detectados, la imagen etiquetada,
# estadísticas y coordenadas de los centroides 
num, y_img, stats, centroids = cv.connectedComponentsWithStats(
	img_bin, cv.CV_32S)

plt.imshow(y_img, 'gray')
plt.show()

# escalando entre 0-255 y guardando
y_img = ImScale(y_img)
cv.imwrite('imagen_etiquetada.png', y_img)

# Impresión de los datos relevantes de cada triángulo
# así como su etiquetado
for i in range(num)[1:]:
  print('\tTriángulo ',i, '\t Área ',stats[i][4],'\tCentroide ', centroids[i])
  if i < 4:
    c = 255
  else:
    c = 0
  cv.putText(y_img, text= str(i), org=(int(centroids[i][0]), int(centroids[i][1])),
            fontFace=cv.FONT_HERSHEY_SIMPLEX, fontScale=1, color=(c, 0, 0),
            thickness=2, lineType=cv.LINE_AA)

plt.imshow(y_img, 'gray')
plt.show()

# guardando imagen etiquetada
cv.imwrite('imagen-enumerada.png', y_img)

"""# Líneas de Hough"""

# Detección de bordes y guardar una copia del resultado 
bordes = cv.Canny(img_bin, 50, 100, 3)
edges = np.copy(bordes)

# Dilatar la imagen con bordes para que la función de HoughLines encuentre más líneas
kernel = np.array([[0,1,0],[1,1,1],[0,1,0]], dtype=np.uint8)
bordes = cv.dilate(bordes, kernel)

# Imagen con solo Bordes
plt.imshow(bordes, 'gray')
plt.show()

# Guardando imagen con solo bordes
cv.imwrite('imagen-bordes.png', bordes)

# Detección de HoughLines en pi/180 y pi/90 para detectar más líneas
lines = cv.HoughLines(bordes, 1, np.pi / 180, 70, None, 50, 10)
lines = lines.reshape(len(lines),2)

lines1 = cv.HoughLines(bordes, 1, np.pi / 90, 70, None, 50, 10)
lines1 = lines1.reshape(len(lines1),2)

# Juntas ambos resultados e imprimir la cantidad de líneas encontradas
lines = np.append(lines, lines1, axis=0)
len(lines)

def delete_aprox_values(array):
  """ 
      Función:  Reducción de elementos parecidos
      
        input: array -> arreglos de valores
      
        output: new_array -> arreglo con valores cercanos entre 0.01 y 0.5 eliminados
  """

  deletes = []; k = 0

  for i in array:
    for j in array[k:]:
      if  0.01 < abs(i - j) < 0.5:
        j = np.where(array == i)[0][0]
        deletes.append(j)
    k += 1
  
  # Borrar los elementos guardados en deletes 
  # e imprimir la cantidad de líneas restante
  new_array = np.delete(array, deletes)
  print(len(new_array))

  return new_array

thetas = []
rhos=[]

# Guardar los valores de theta y rho en 2 arreglos distintos
for i in lines: thetas.append(i[1])

thetas = delete_aprox_values(thetas)

for i in thetas:
  if np.any(lines[:] == i):
    j = np.where(lines==i)[0][0]
    rhos.append(lines[j][0])

# Colores distintos para cada línea creada
colors = np.round(np.linspace(50,240,len(rhos)),0)

# Dibujando las líneas sobre la imagen de bordes
for rho, theta, color in zip(rhos, thetas, colors):
    a = np.cos(theta)
    b = np.sin(theta)
    x0 = a*rho
    y0 = b*rho
    x1 = int(x0 + 1000*(-b))
    y1 = int(y0 + 1000*(a))
    x2 = int(x0 - 1000*(-b))
    y2 = int(y0 - 1000*(a))
    cv.line(bordes,(x1,y1),(x2,y2),(color,0,0),1)

# Mostrar la imagen de Bordes con las líneas de Hough
plt.imshow(bordes)
plt.show()

# Mostrando la imagen en Plotly para detectar los valores de cada línea por su color
fig = px.imshow(bordes, color_continuous_scale='gray')
fig.show()

# líneas de interés
c_lin = [172, 188, 165, 154, 100, 143, 140, 136, 139, 62, 155, 187, 156, 80, 50, 203, 186, 52]
len(c_lin)

# Obtener una copia de la imagen de bordes con líneas de Hough 
# para eliminar cada línea que no sea de interés
im = np.copy(bordes)

im[im == 255] = 0
for i in colors:
  if i not in c_lin:
    im[im == i] = 0

# Mostrando el resultado
plt.imshow(im,'gray')
plt.show()

# Imprimir los valores de rho y theta de cada línea de ineterés ubicada por su color
colores = colors.astype('int')

for rho, theta, color in zip(rhos, thetas, colores):
  if color in c_lin:
    print('\tRho: ',rho,'\tTheta: ', theta, '\tColor', color)

# Creando una copia de la imagen de bordes para juntarla con la que tiene 
# las líneas de Hough de interés y maximizar su color

h_lines = np.copy(im)
h_lines[h_lines != 0] = 200
h_lines += edges

# h_lines = cv.dilate(h_lines, kernel)

# for rho, theta, color in zip(rhos, thetas, colors):
#     if color in c_lin:
#       a = np.cos(theta);        b = np.sin(theta)
#       x0 = a*rho;               y0 = b*rho
#       x1 = int(x0 + 1000*(-b)); y1 = int(y0 + 1000*(a))
#       x2 = int(x0 - 1000*(-b)); y2 = int(y0 - 1000*(a))

#       cv.line(h_lines, (x1,y1), (x2,y2), (200,0,0), 1)

plt.imshow(h_lines, 'gray')
plt.show()

cv.imwrite('hough-lines.png', h_lines)

"""# Segmentación de Aristas"""

import imutils

# Encontrando las vértices de cada triángulo
cnts = cv.findContours(img_bin, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
cnts = imutils.grab_contours(cnts)
vertices = []

for c in cnts:
    # apriximando el contorno
    peri = cv.arcLength(c, True)
    approx = cv.approxPolyDP(c, 0.02 * peri, True)
    # si la aproximación tiene 3 vértices, guardar 
    if len(approx) == 3:
        vertices.append(approx)


# convirtiendo a np.array y cambiando la forma a una más conveniente
vertices = np.array(vertices)
vertices = vertices.reshape(6,3,2)

def distance(p1, p2):
  """
      Función que calcula la distancia en pixeles entre 2 puntos
      
      input: p1 y p2 vectores de 2 componentes
      output: entero de la distancia euclideana 
  """
  dis = (( p1[0] - p2[0] ) ** 2 + ( p1[1] - p2[1] ) ** 2 )**0.5
  dis = int(dis)
  
  return dis

def center(p1, p2):
  """
        Función que recibe 2 puntos y encuentra el centro entre ellos

        input: p1 y p2 vectores con las coordenadas de los puntos
        output: p3 vector con el centro entre los 2 puntos
  """
  p3 = [0,0]
  
  p3[0] = (p1[0] + p2[0]) // 2
  p3[1] = (p1[1] + p2[1]) // 2

  return p3

# Mostrar las distancias o logitudes entre cada vértice
for i in reversed(vertices):
  print('\t',i[0] ,'-',i[1], ':' , distance(i[0], i[1]),'\t',i[1] ,'-',i[2], ':' ,
        distance(i[1], i[2]),'\t',i[0] ,'-',i[2], ':' , distance(i[0], i[2]) )

# Imprimiendo el centro entre cada arista
for i in reversed(vertices):
  print('\t',i[0] ,'-',i[1], ':' , center(i[0], i[1]),'\t',i[1] ,'-',i[2], ':' ,
        center(i[1], i[2]),'\t',i[0] ,'-',i[2], ':' , center(i[0], i[2]) )

# Etiquetando cada arista y aguardando en aris

aris = np.copy(edges)
k = 0

for i in reversed(vertices):
  for j in range(3):
    c = center(i[j-1],i[j])
    cv.putText(aris, text= str(k+1), org=(c[0]+5,c[1]),
            fontFace= cv.FONT_HERSHEY_SIMPLEX, fontScale=0.7, color=(255,0,0),
            thickness=2, lineType=cv.LINE_AA)
    k += 1

# Mostrando las aristas etiquetadas
plt.imshow(aris,'gray')
plt.show()

# Etiquetando también la imagen con las líneas de Houge

arish = np.copy(h_lines)
k = 0

for i in reversed(vertices):
  for j in range(3):
    c = center(i[j-1],i[j])
    cv.putText(arish, text= str(k+1), org=(c[0]+5,c[1]-10),
            fontFace= cv.FONT_HERSHEY_SIMPLEX, fontScale=0.7, color=(255,0,0),
            thickness=2, lineType=cv.LINE_AA)
    k += 1

plt.imshow(arish,'gray')
plt.show()

# Guardando la longitud de cada arista
distances = []

for i in reversed(vertices):
  for j in range(3):
    distances.append(distance(i[j-1],i[j]))

# Diccionario con los colores y etiqueta correspondiente de cada arista

h_labels = {172:11, 188:12, 165:10, 154:6, 100:5, 143:4, 140:13, 136:14, 139:15,
            62:2, 155:1, 187:3, 156:8, 80:7, 50:9, 203:17, 186:16, 52:18}

# Imprimiendo los datos obtenidos y guardando los números con su respectivo ángulo
numbers = []
angles = []
p = []

for color, rho, the in zip(colors, rhos, thetas):
  if color in h_labels.keys():
    index = h_labels[int(color)]
    print('\t Arista '+str(index), '\t Theta', round(the,2),
          '\t Rho', int(rho), '\t Longitud', distances[index-1])
    numbers.append(index)
    angles.append(the)
    p.append(rho)

# Guardando las imágenes con las aristas etiquetadas
cv.imwrite('image-aristas.png', aris)
cv.imwrite('image-aristas-hough.png', arish)

# Resaltando cada vértice y guardando en la variable vert

vert = np.copy(edges)
k = 0

for i in reversed(vertices):
  for j in i:
    vert = cv.circle(vert, (j[0],j[1]), radius=3, color=(255, 0, 0), thickness=2)
    cv.putText(vert, text= str(k+1), org=(j[0]+10,j[1]),
            fontFace= cv.FONT_HERSHEY_SIMPLEX, fontScale=0.6, color=(255,0,0),
            thickness=2, lineType=cv.LINE_AA)
    k += 1

plt.imshow(vert,'gray')
plt.show()

# Guardando la imagen con las vértices etiquetadas
cv.imwrite('image-vertices.png', vert)

"""# Rectas Paralelas"""

# Buscando grupos de rectas paralelas con margen de 0.04 radianes
k = 0
for i, m in zip(angles, numbers):
  for j, n in zip(angles[k:], numbers[k:]):
    if abs(i - j) < 0.07 and n != m:
      print(m, n)
  k += 1

grupos = {'A' : [9, 18], 'B': [7, 1, 16], 'C' : [6, 11, 13], 'D' : [2, 5], 'E' : [8, 17]}
grupos

paralelas = np.copy(edges)
tonos = {'A':250, 'B':230, 'C':210, 'D':190,'E': 170}
k=0;

for i in reversed(vertices):
  for j in range(3):
    for name, grupo in grupos.items():
      if k+1 in grupo:
        c = center(i[j-1],i[j])
        cv.putText(paralelas, text=name, org=(c[0]+5,c[1]),
            fontFace= cv.FONT_HERSHEY_SIMPLEX, fontScale=0.8, color=(tonos[name],0,0),
            thickness=2, lineType=cv.LINE_AA)
    k += 1

plt.imshow(paralelas, 'gray')
plt.show()

cv.imwrite('image-paralelas.png', paralelas)

"""# Cálculo del Centroide con $\rho$ y $\theta$

Se puede calcular los centroides con
"""

centroid = []

for i in reversed(vertices):
  x = 0
  y = 0
  for j in range(3):
    x += i[j][0]
    y += i[j][1]
  print([x//3,y//3])
  centroid.append([x//3,y//3])

#centroid
